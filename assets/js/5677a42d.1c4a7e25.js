(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[751],{3905:function(n,e,t){"use strict";t.d(e,{Zo:function(){return u},kt:function(){return l}});var r=t(7294);function i(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function a(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){i(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function s(n,e){if(null==n)return{};var t,r,i=function(n,e){if(null==n)return{};var t,r,i={},o=Object.keys(n);for(r=0;r<o.length;r++)t=o[r],e.indexOf(t)>=0||(i[t]=n[t]);return i}(n,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(r=0;r<o.length;r++)t=o[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(i[t]=n[t])}return i}var c=r.createContext({}),m=function(n){var e=r.useContext(c),t=e;return n&&(t="function"==typeof n?n(e):a(a({},e),n)),t},u=function(n){var e=m(n.components);return r.createElement(c.Provider,{value:e},n.children)},p={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},g=r.forwardRef((function(n,e){var t=n.components,i=n.mdxType,o=n.originalType,c=n.parentName,u=s(n,["components","mdxType","originalType","parentName"]),g=m(t),l=i,d=g["".concat(c,".").concat(l)]||g[l]||p[l]||o;return t?r.createElement(d,a(a({ref:e},u),{},{components:t})):r.createElement(d,a({ref:e},u))}));function l(n,e){var t=arguments,i=e&&e.mdxType;if("string"==typeof n||i){var o=t.length,a=new Array(o);a[0]=g;var s={};for(var c in e)hasOwnProperty.call(e,c)&&(s[c]=e[c]);s.originalType=n,s.mdxType="string"==typeof n?n:i,a[1]=s;for(var m=2;m<o;m++)a[m]=t[m];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}g.displayName="MDXCreateElement"},829:function(n,e,t){"use strict";t.r(e),t.d(e,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return m},toc:function(){return u},default:function(){return g}});var r=t(4034),i=t(9973),o=(t(7294),t(3905)),a=["components"],s={id:"minsnaptrajectory",title:"Minimum Snap Trajectory",sidebar_label:"Minimum Snap Trajectory"},c=void 0,m={unversionedId:"motion-planning/ZJU-FAST-Lab/minsnaptrajectory",id:"motion-planning/ZJU-FAST-Lab/minsnaptrajectory",isDocsHomePage:!1,title:"Minimum Snap Trajectory",description:"Overview",source:"@site/docs/motion-planning/ZJU-FAST-Lab/minsnaptrajectory.md",sourceDirName:"motion-planning/ZJU-FAST-Lab",slug:"/motion-planning/ZJU-FAST-Lab/minsnaptrajectory",permalink:"/docusaurus/docs/motion-planning/ZJU-FAST-Lab/minsnaptrajectory",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/motion-planning/ZJU-FAST-Lab/minsnaptrajectory.md",version:"current",lastUpdatedAt:1627204896,formattedLastUpdatedAt:"7/25/2021",frontMatter:{id:"minsnaptrajectory",title:"Minimum Snap Trajectory",sidebar_label:"Minimum Snap Trajectory"},sidebar:"MotionPlanningSidebar",previous:{title:"Trajectory Generation",permalink:"/docusaurus/docs/motion-planning/introduction/trajectory"}},u=[{value:"Overview",id:"overview",children:[]},{value:"ZJU-FAST-Lab",id:"zju-fast-lab",children:[]}],p={toc:u};function g(n){var e=n.components,t=(0,i.Z)(n,a);return(0,o.kt)("wrapper",(0,r.Z)({},p,t,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h3",{id:"overview"},"Overview"),(0,o.kt)("p",null,"ZJU implementation of the multiple segments of a polynomial-based trajectory from its starting waypoint to an ending waypoint."),(0,o.kt)("h3",{id:"zju-fast-lab"},"ZJU-FAST-Lab"),(0,o.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"The content below is from ",(0,o.kt)("strong",{parentName:"p"},"PolynomialTraj::minSnapTraj")," function."),(0,o.kt)("pre",{parentName:"div"},(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"PolynomialTraj PolynomialTraj::minSnapTraj(\n    const Eigen::MatrixXd &Pos, \n    const Eigen::Vector3d &start_vel,\n    const Eigen::Vector3d &end_vel, \n    const Eigen::Vector3d &start_acc,\n    const Eigen::Vector3d &end_acc, \n    const Eigen::VectorXd &Time)\n")))),(0,o.kt)("h4",{id:"whole-code"},"Whole code"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"PolynomialTraj PolynomialTraj::minSnapTraj(\n    const Eigen::MatrixXd &Pos, \n    const Eigen::Vector3d &start_vel,\n    const Eigen::Vector3d &end_vel, \n    const Eigen::Vector3d &start_acc,\n    const Eigen::Vector3d &end_acc, \n    const Eigen::VectorXd &Time)\n  {\n    int seg_num = Time.size();\n    Eigen::MatrixXd poly_coeff(seg_num, 3 * 6);\n    Eigen::VectorXd Px(6 * seg_num), Py(6 * seg_num), Pz(6 * seg_num);\n\n    int num_f, num_p; // number of fixed and free variables\n    int num_d;        // number of all segments' derivatives\n\n    const static auto Factorial = [](int x) {\n      int fac = 1;\n      for (int i = x; i > 0; i--)\n        fac = fac * i;\n      return fac;\n    };\n\n    /* ---------- end point derivative ---------- */\n    Eigen::VectorXd Dx = Eigen::VectorXd::Zero(seg_num * 6);\n    Eigen::VectorXd Dy = Eigen::VectorXd::Zero(seg_num * 6);\n    Eigen::VectorXd Dz = Eigen::VectorXd::Zero(seg_num * 6);\n\n    for (int k = 0; k < seg_num; k++)\n    {\n      /* position to derivative */\n      Dx(k * 6) = Pos(0, k);\n      Dx(k * 6 + 1) = Pos(0, k + 1);\n      Dy(k * 6) = Pos(1, k);\n      Dy(k * 6 + 1) = Pos(1, k + 1);\n      Dz(k * 6) = Pos(2, k);\n      Dz(k * 6 + 1) = Pos(2, k + 1);\n\n      if (k == 0)\n      {\n        Dx(k * 6 + 2) = start_vel(0);\n        Dy(k * 6 + 2) = start_vel(1);\n        Dz(k * 6 + 2) = start_vel(2);\n\n        Dx(k * 6 + 4) = start_acc(0);\n        Dy(k * 6 + 4) = start_acc(1);\n        Dz(k * 6 + 4) = start_acc(2);\n      }\n      else if (k == seg_num - 1)\n      {\n        Dx(k * 6 + 3) = end_vel(0);\n        Dy(k * 6 + 3) = end_vel(1);\n        Dz(k * 6 + 3) = end_vel(2);\n\n        Dx(k * 6 + 5) = end_acc(0);\n        Dy(k * 6 + 5) = end_acc(1);\n        Dz(k * 6 + 5) = end_acc(2);\n      }\n    }\n\n    /* ---------- Mapping Matrix A ---------- */\n    Eigen::MatrixXd Ab;\n    Eigen::MatrixXd A = Eigen::MatrixXd::Zero(seg_num * 6, seg_num * 6);\n\n    for (int k = 0; k < seg_num; k++)\n    {\n      Ab = Eigen::MatrixXd::Zero(6, 6);\n      for (int i = 0; i < 3; i++)\n      {\n        Ab(2 * i, i) = Factorial(i);\n        for (int j = i; j < 6; j++)\n          Ab(2 * i + 1, j) = Factorial(j) / Factorial(j - i) * pow(Time(k), j - i);\n      }\n      A.block(k * 6, k * 6, 6, 6) = Ab;\n    }\n\n    /* ---------- Produce Selection Matrix C' ---------- */\n    Eigen::MatrixXd Ct, C;\n\n    num_f = 2 * seg_num + 4; // 3 + 3 + (seg_num - 1) * 2 = 2m + 4\n    num_p = 2 * seg_num - 2; //(seg_num - 1) * 2 = 2m - 2\n    num_d = 6 * seg_num;\n    Ct = Eigen::MatrixXd::Zero(num_d, num_f + num_p);\n    Ct(0, 0) = 1;\n    Ct(2, 1) = 1;\n    Ct(4, 2) = 1; // stack the start point\n    Ct(1, 3) = 1;\n    Ct(3, 2 * seg_num + 4) = 1;\n    Ct(5, 2 * seg_num + 5) = 1;\n\n    Ct(6 * (seg_num - 1) + 0, 2 * seg_num + 0) = 1;\n    Ct(6 * (seg_num - 1) + 1, 2 * seg_num + 1) = 1; // Stack the end point\n    Ct(6 * (seg_num - 1) + 2, 4 * seg_num + 0) = 1;\n    Ct(6 * (seg_num - 1) + 3, 2 * seg_num + 2) = 1; // Stack the end point\n    Ct(6 * (seg_num - 1) + 4, 4 * seg_num + 1) = 1;\n    Ct(6 * (seg_num - 1) + 5, 2 * seg_num + 3) = 1; // Stack the end point\n\n    for (int j = 2; j < seg_num; j++)\n    {\n      Ct(6 * (j - 1) + 0, 2 + 2 * (j - 1) + 0) = 1;\n      Ct(6 * (j - 1) + 1, 2 + 2 * (j - 1) + 1) = 1;\n      Ct(6 * (j - 1) + 2, 2 * seg_num + 4 + 2 * (j - 2) + 0) = 1;\n      Ct(6 * (j - 1) + 3, 2 * seg_num + 4 + 2 * (j - 1) + 0) = 1;\n      Ct(6 * (j - 1) + 4, 2 * seg_num + 4 + 2 * (j - 2) + 1) = 1;\n      Ct(6 * (j - 1) + 5, 2 * seg_num + 4 + 2 * (j - 1) + 1) = 1;\n    }\n\n    C = Ct.transpose();\n\n    Eigen::VectorXd Dx1 = C * Dx;\n    Eigen::VectorXd Dy1 = C * Dy;\n    Eigen::VectorXd Dz1 = C * Dz;\n\n    /* ---------- minimum snap matrix ---------- */\n    Eigen::MatrixXd Q = Eigen::MatrixXd::Zero(seg_num * 6, seg_num * 6);\n\n    for (int k = 0; k < seg_num; k++)\n    {\n      for (int i = 3; i < 6; i++)\n      {\n        for (int j = 3; j < 6; j++)\n        {\n          Q(k * 6 + i, k * 6 + j) =\n              i * (i - 1) * (i - 2) * j * (j - 1) * (j - 2) / (i + j - 5) * pow(Time(k), (i + j - 5));\n        }\n      }\n    }\n\n    /* ---------- R matrix ---------- */\n    Eigen::MatrixXd R = C * A.transpose().inverse() * Q * A.inverse() * Ct;\n\n    Eigen::VectorXd Dxf(2 * seg_num + 4), Dyf(2 * seg_num + 4), Dzf(2 * seg_num + 4);\n\n    Dxf = Dx1.segment(0, 2 * seg_num + 4);\n    Dyf = Dy1.segment(0, 2 * seg_num + 4);\n    Dzf = Dz1.segment(0, 2 * seg_num + 4);\n\n    Eigen::MatrixXd Rff(2 * seg_num + 4, 2 * seg_num + 4);\n    Eigen::MatrixXd Rfp(2 * seg_num + 4, 2 * seg_num - 2);\n    Eigen::MatrixXd Rpf(2 * seg_num - 2, 2 * seg_num + 4);\n    Eigen::MatrixXd Rpp(2 * seg_num - 2, 2 * seg_num - 2);\n\n    Rff = R.block(0, 0, 2 * seg_num + 4, 2 * seg_num + 4);\n    Rfp = R.block(0, 2 * seg_num + 4, 2 * seg_num + 4, 2 * seg_num - 2);\n    Rpf = R.block(2 * seg_num + 4, 0, 2 * seg_num - 2, 2 * seg_num + 4);\n    Rpp = R.block(2 * seg_num + 4, 2 * seg_num + 4, 2 * seg_num - 2, 2 * seg_num - 2);\n\n    /* ---------- close form solution ---------- */\n\n    Eigen::VectorXd Dxp(2 * seg_num - 2), Dyp(2 * seg_num - 2), Dzp(2 * seg_num - 2);\n    Dxp = -(Rpp.inverse() * Rfp.transpose()) * Dxf;\n    Dyp = -(Rpp.inverse() * Rfp.transpose()) * Dyf;\n    Dzp = -(Rpp.inverse() * Rfp.transpose()) * Dzf;\n\n    Dx1.segment(2 * seg_num + 4, 2 * seg_num - 2) = Dxp;\n    Dy1.segment(2 * seg_num + 4, 2 * seg_num - 2) = Dyp;\n    Dz1.segment(2 * seg_num + 4, 2 * seg_num - 2) = Dzp;\n\n    Px = (A.inverse() * Ct) * Dx1;\n    Py = (A.inverse() * Ct) * Dy1;\n    Pz = (A.inverse() * Ct) * Dz1;\n\n    for (int i = 0; i < seg_num; i++)\n    {\n      poly_coeff.block(i, 0, 1, 6) = Px.segment(i * 6, 6).transpose();\n      poly_coeff.block(i, 6, 1, 6) = Py.segment(i * 6, 6).transpose();\n      poly_coeff.block(i, 12, 1, 6) = Pz.segment(i * 6, 6).transpose();\n    }\n\n    /* ---------- use polynomials ---------- */\n    PolynomialTraj poly_traj;\n    for (int i = 0; i < poly_coeff.rows(); ++i)\n    {\n      vector<double> cx(6), cy(6), cz(6);\n      for (int j = 0; j < 6; ++j)\n      {\n        cx[j] = poly_coeff(i, j), cy[j] = poly_coeff(i, j + 6), cz[j] = poly_coeff(i, j + 12);\n      }\n      reverse(cx.begin(), cx.end());\n      reverse(cy.begin(), cy.end());\n      reverse(cz.begin(), cz.end());\n      double ts = Time(i);\n      poly_traj.addSegment(cx, cy, cz, ts);\n    }\n\n    return poly_traj;\n  }\n")))}g.isMDXComponent=!0}}]);