(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[186],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return s},kt:function(){return u}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),d=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},s=function(e){var t=d(e.components);return a.createElement(p.Provider,{value:t},e.children)},_={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),c=d(n),u=i,m=c["".concat(p,".").concat(u)]||c[u]||_[u]||r;return n?a.createElement(m,l(l({ref:t},s),{},{components:n})):a.createElement(m,l({ref:t},s))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=c;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var d=2;d<r;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},1104:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return p},metadata:function(){return d},toc:function(){return s},default:function(){return c}});var a=n(4034),i=n(9973),r=(n(7294),n(3905)),l=["components"],o={id:"land",title:"Landing Control",sidebar_label:"Landing Control"},p=void 0,d={unversionedId:"px4-autopilot/fixedwing/land",id:"px4-autopilot/fixedwing/land",isDocsHomePage:!1,title:"Landing Control",description:"Overview",source:"@site/docs/px4-autopilot/fixedwing/land.md",sourceDirName:"px4-autopilot/fixedwing",slug:"/px4-autopilot/fixedwing/land",permalink:"/docusaurus/docs/px4-autopilot/fixedwing/land",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/px4-autopilot/fixedwing/land.md",version:"current",lastUpdatedAt:1627525377,formattedLastUpdatedAt:"7/29/2021",frontMatter:{id:"land",title:"Landing Control",sidebar_label:"Landing Control"},sidebar:"Px4Sidebar",previous:{title:"Introduction",permalink:"/docusaurus/docs/px4-autopilot/introduction/intro"}},s=[{value:"Overview",id:"overview",children:[]},{value:"Code Review",id:"code-review",children:[]},{value:"Findings",id:"findings",children:[]},{value:"Initialization",id:"initialization",children:[{value:"Constrain TECS",id:"constrain-tecs",children:[]},{value:"Reset Logical States",id:"reset-logical-states",children:[]},{value:"Heading",id:"heading",children:[]},{value:"Find Seperation Distance",id:"find-seperation-distance",children:[]},{value:"Find Waypoint Offset",id:"find-waypoint-offset",children:[]},{value:"Heading Hold on Condition",id:"heading-hold-on-condition",children:[]},{value:"Set Terrain Altitude",id:"set-terrain-altitude",children:[]}]},{value:"Controls",id:"controls",children:[{value:"FW Descend",id:"fw-descend",children:[]},{value:"FW Flare",id:"fw-flare",children:[]}]},{value:"Helper Functions",id:"helper-functions",children:[]}],_={toc:s};function c(e){var t=e.components,o=(0,i.Z)(e,l);return(0,r.kt)("wrapper",(0,a.Z)({},_,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"The overview can be seen in ",(0,r.kt)("inlineCode",{parentName:"p"},"PX4.io")," official documentation on ",(0,r.kt)("inlineCode",{parentName:"p"},"Fixed Wing Landing")," and the documentation can be found ",(0,r.kt)("a",{parentName:"p",href:"https://docs.px4.io/v1.12/en/flying/fixed_wing_landing.html"},"here")," "))),(0,r.kt)("p",null,"PX4 enables ",(0,r.kt)("strong",{parentName:"p"},"autopilot-controlled fixed-wing (FW) landing")," in ",(0,r.kt)("strong",{parentName:"p"},"Missions")," mode, ",(0,r.kt)("strong",{parentName:"p"},"Land")," mode and ",(0,r.kt)("strong",{parentName:"p"},"Return")," mode."),(0,r.kt)("p",null,"The landing logic has several phases, as shown below. In the first phase the vehicle will follow a fixed trajectory (",(0,r.kt)("strong",{parentName:"p"},"FW_LND_ANG"),") towards the ground. At the flare landing altitude (",(0,r.kt)("strong",{parentName:"p"},"FW_LND_FLALT"),") the vehicle will start to follow a flare path (the curve is based on the value of ",(0,r.kt)("strong",{parentName:"p"},"FW_LND_HVIRT"),")."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Fixed Wing Landing Path",src:n(5156).Z})),(0,r.kt)("p",null,'The flare landing altitude is relative to the altitude that the FW vehicle "',(0,r.kt)("strong",{parentName:"p"},"thinks"),'" is ground level. In ',(0,r.kt)("strong",{parentName:"p"},"Land mode")," the ground altitude is not known and the vehicle will use assume it is at 0m (",(0,r.kt)("strong",{parentName:"p"},"sea level"),"). Often the ground level will be much higher than sea level, so the vehicle will land in the ",(0,r.kt)("strong",{parentName:"p"},"first phase")," (",(0,r.kt)("strong",{parentName:"p"},"it will land on the ground before it reaches the flare altitude"),")."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"center"},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:"center"},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("font",{color:"LightGreen"}," FW_LND_ANG "))),(0,r.kt)("td",{parentName:"tr",align:"center"},"Landing slope angle prior to flaring")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("font",{color:"LightGreen"}," FW_LND_HVIRT "))),(0,r.kt)("td",{parentName:"tr",align:"center"},"Virtual horizontal line/altitude used to calculate the flare trajectory. This represents the sub-ground altitude that the flare-path curve asymptotically approaches.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("font",{color:"LightGreen"}," FW_LND_HVIRT "))),(0,r.kt)("td",{parentName:"tr",align:"center"},"Virtual horizontal line/altitude used to calculate the flare trajectory. This represents the sub-ground altitude that the flare-path curve asymptotically approaches.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("font",{color:"LightGreen"}," FW_LND_FLALT "))),(0,r.kt)("td",{parentName:"tr",align:"center"},"Landing flare altitude (relative to landing altitude)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("font",{color:"LightGreen"}," FW_LND_TLALT "))),(0,r.kt)("td",{parentName:"tr",align:"center"},"Landing throttle limit altitude (relative landing altitude). The default value of -1.0 lets the system default to applying throttle limiting at 2/3 of the flare altitude.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("font",{color:"LightGreen"}," FW_LND_HHDIST "))),(0,r.kt)("td",{parentName:"tr",align:"center"},"Landing heading hold horizontal distance")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("font",{color:"LightGreen"}," FW_LND_USETER "))),(0,r.kt)("td",{parentName:"tr",align:"center"},"Use terrain estimate (ground altitude from GPS) during landing. This is turned off by default and a waypoint or return altitude is normally used (or sea level for an arbitrary land position).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("font",{color:"LightGreen"}," FW_LND_FL_PMIN "))),(0,r.kt)("td",{parentName:"tr",align:"center"},"Minimum pitch during flare. A positive sign means nose up Applied once FW_LND_TLALT is reached")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("font",{color:"LightGreen"}," FW_LND_FL_PMAX "))),(0,r.kt)("td",{parentName:"tr",align:"center"},"Maximum pitch during flare. A positive sign means nose up Applied once FW_LND_TLALT is reached")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("font",{color:"LightGreen"}," FW_LND_AIRSPD_SC "))),(0,r.kt)("td",{parentName:"tr",align:"center"},"Min. airspeed scaling factor for landing. Comment: Multiplying this factor with the minimum airspeed of the plane gives the target airspeed the landing approach. ",(0,r.kt)("inlineCode",{parentName:"td"},"FW_AIRSPD_MIN x FW_LND_AIRSPD_SC"))))),(0,r.kt)("p",null,"Sample values for FW with changed values being highlighted in ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("font",{color:"red"}," RED "))," :"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("img",{src:n(3327).Z}))))),(0,r.kt)("h2",{id:"code-review"},"Code Review"),(0,r.kt)("p",null,"Function in ",(0,r.kt)("inlineCode",{parentName:"p"},"FixedwingPositionControl.cpp"),", this is called when ",(0,r.kt)("inlineCode",{parentName:"p"},"commander land")," is used in the ",(0,r.kt)("strong",{parentName:"p"},"mav console")," which will switch the ",(0,r.kt)("inlineCode",{parentName:"p"},"position_sp_type")," to ",(0,r.kt)("strong",{parentName:"p"},"4")," which refers to ",(0,r.kt)("inlineCode",{parentName:"p"},"SETPOINT_TYPE_LAND (4)")," where default is ",(0,r.kt)("strong",{parentName:"p"},"2")," ",(0,r.kt)("inlineCode",{parentName:"p"},"SETPOINT_TYPE_LOITER (2)"),". This is becasue the UAV is always going to loiter around the waypoint. you can find the different modes under the UORB message ",(0,r.kt)("inlineCode",{parentName:"p"},"position_setpoint"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void\nFixedwingPositionControl::control_landing(\n    const hrt_abstime &now, \n    const Vector2d &curr_pos,\n    const Vector2f &ground_speed, \n    const position_setpoint_s &pos_sp_prev, \n    const position_setpoint_s &pos_sp_curr)\n")),(0,r.kt)("h2",{id:"findings"},"Findings"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Apparently after checking normally ",(0,r.kt)("inlineCode",{parentName:"p"},"!pos_sp_prev.valid")," meaning that there is no ",(0,r.kt)("inlineCode",{parentName:"p"},"pos_sp.valid")," and the current ",(0,r.kt)("inlineCode",{parentName:"p"},"lat")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"long")," is used as the ",(0,r.kt)("inlineCode",{parentName:"p"},"prev_wp"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"There is a flaw in the landing logic, where the bearing is locked, and the roll and yaw control is locked as it descends, since it takes ",(0,r.kt)("inlineCode",{parentName:"p"},"Vector2d curr_wp(pos_sp_curr.lat, pos_sp_curr.lon);")," the current waypoint to be its one position, not the next setpoint that was given (",(0,r.kt)("strong",{parentName:"p"},"this has to be changed!"),")"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("img",{alt:"Fixed Wing Landing QGC",src:n(936).Z})),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("img",{alt:"Fixed Wing Landing Terminal",src:n(552).Z}))))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The mavlink command from QGC is sent to ",(0,r.kt)("inlineCode",{parentName:"li"},"POSITION_TARGET_GLOBAL_INT")," and it is under the ",(0,r.kt)("inlineCode",{parentName:"li"},".lat_int"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"lon_int")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"alt")," and the current position is under ",(0,r.kt)("inlineCode",{parentName:"li"},"GLOBAL_POSITION_INT")," and the values for latitude, longitude and altitude is ",(0,r.kt)("inlineCode",{parentName:"li"},"lat"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"lon")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"alt"),".")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("img",{alt:"Fixed Wing Mav Setpoints",src:n(1755).Z}))))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"After sending ",(0,r.kt)("inlineCode",{parentName:"p"},"commander land")," the ",(0,r.kt)("inlineCode",{parentName:"p"},"NAV_CONTROLLER_OUTPUT.wp_dist")," = 0 since it assumes the current position is the current waypoint, we need to implement the UAV to land with a specific global coordinates.  ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Heading Hold")," is activated after ",(0,r.kt)("inlineCode",{parentName:"p"},"Flare")," hence the height is according to the ",(0,r.kt)("inlineCode",{parentName:"p"},"FW_LND_FLALT")," height.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"getLandingSlopeRelativeAltitudeSave")," only activates and ",(0,r.kt)("strong",{parentName:"p"},"returns")," the ",(0,r.kt)("strong",{parentName:"p"},"slope altitude")," when the current bearing is close to the final bearing (",(0,r.kt)("strong",{parentName:"p"},"desired"),")"))),(0,r.kt)("h2",{id:"initialization"},"Initialization"),(0,r.kt)("p",null,"The start of the function is to initialise the start and end points for the landing maneuver, the start would be the current position if ",(0,r.kt)("inlineCode",{parentName:"p"},"!pos_sp_prev.valid")," and will use the current ",(0,r.kt)("inlineCode",{parentName:"p"},"longitude")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"latitude")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"/* current waypoint (the one currently heading for) */\nVector2d curr_wp(pos_sp_curr.lat, pos_sp_curr.lon);\nVector2d prev_wp{0, 0}; /* previous waypoint */\n\nif (pos_sp_prev.valid) {\n    prev_wp(0) = pos_sp_prev.lat;\n    prev_wp(1) = pos_sp_prev.lon;\n\n} else {\n    /*\n    * No valid previous waypoint, go for the current wp.\n    * This is automatically handled by the L1 library.\n    */\n    prev_wp(0) = pos_sp_curr.lat;\n    prev_wp(1) = pos_sp_curr.lon;\n}\n")),(0,r.kt)("h3",{id:"constrain-tecs"},"Constrain TECS"),(0,r.kt)("p",null,"The TECS would have a higher ",(0,r.kt)("inlineCode",{parentName:"p"},"_height_error_gain"),", this is to have the UAV maintain the altitude on the course that PX4 has desired ",(0,r.kt)("inlineCode",{parentName:"p"},"_height_error_gain = 1.0f / math::max(time_const, 0.1f)"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// Enable tighter altitude control for landings\n_tecs.set_height_error_time_constant(_param_fw_thrtc_sc.get() * _param_fw_t_h_error_tc.get());\n")),(0,r.kt)("h3",{id:"reset-logical-states"},"Reset Logical States"),(0,r.kt)("p",null,"We need to reset some of the logical states that help to govern the landing process"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// _time_started_landing = 0;\n\n// reset terrain estimation relevant values\n// _time_last_t_alt = 0;\n// _land_noreturn_horizontal = false;\n// _land_noreturn_vertical = false;\n// _land_stayonground = false;\n// _land_motor_lim = false;\n// _land_onslope = false;\nreset_landing_state();\n_time_started_landing = now;\n")),(0,r.kt)("h3",{id:"heading"},"Heading"),(0,r.kt)("p",null,"Also we have to change the ",(0,r.kt)("strong",{parentName:"p"},"bearing")," of the airplane to face the bearing of the landing point ",(0,r.kt)("inlineCode",{parentName:"p"},"bearing_lastwp_currwp"),". "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"const float bearing_airplane_currwp = get_bearing_to_next_waypoint(\n    (double)curr_pos(0), \n    (double)curr_pos(1),\n    (double)curr_wp(0), \n    (double)curr_wp(1));\nfloat bearing_lastwp_currwp = bearing_airplane_currwp;\n// seems like the value is overwritten if there is a valid previous waypoint\nif (pos_sp_prev.valid) {\n    bearing_lastwp_currwp = get_bearing_to_next_waypoint(\n        (double)prev_wp(0), \n        (double)prev_wp(1), \n        (double)curr_wp(0),\n        (double)curr_wp(1));\n}\n")),(0,r.kt)("h3",{id:"find-seperation-distance"},"Find Seperation Distance"),(0,r.kt)("p",null,"Finding the distance to calculate for, which is the seperation distance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"/* Horizontal landing control */\n/* switch to heading hold for the last meters, continue heading hold after */\nfloat wp_distance = get_distance_to_next_waypoint(\n    (double)curr_pos(0), \n    (double)curr_pos(1), \n    (double)curr_wp(0),\n    (double)curr_wp(1));\n\n/* calculate a waypoint distance value which is 0 when the aircraft is behind the waypoint */\nfloat wp_distance_save = wp_distance;\n\nif (fabsf(wrap_pi(bearing_airplane_currwp - bearing_lastwp_currwp)) >= radians(90.0f)) {\n    wp_distance_save = 0.0f;\n}\n")),(0,r.kt)("h3",{id:"find-waypoint-offset"},"Find Waypoint Offset"),(0,r.kt)("p",null,"This is a helpful function to create a waypoint to track (",(0,r.kt)("strong",{parentName:"p"},"virtual final destination"),"), the plane will use the ",(0,r.kt)("inlineCode",{parentName:"p"},"pos_sp_prev")," (if valid) to the ",(0,r.kt)("inlineCode",{parentName:"p"},"pos_sp_curr")," "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Hence if we do not have ",(0,r.kt)("inlineCode",{parentName:"li"},"pos_sp_prev")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"pos_sp_curr"),", the default is ",(0,r.kt)("inlineCode",{parentName:"li"},"pos_sp_prev = pos_sp_curr = current position"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// create virtual waypoint which is on the desired flight path but\n// some distance behind landing waypoint. This will make sure that the plane\n// will always follow the desired flight path even if we get close or past\n// the landing waypoint\nif (pos_sp_prev.valid) {\n    double lat = pos_sp_curr.lat;\n    double lon = pos_sp_curr.lon;\n\n    create_waypoint_from_line_and_dist(\n        pos_sp_curr.lat,\n        pos_sp_curr.lon,\n        pos_sp_prev.lat,\n        pos_sp_prev.lon,\n        -1000.0f, &lat, &lon);\n\n    curr_wp(0) = lat;\n    curr_wp(1) = lon;\n}\n")),(0,r.kt)("h3",{id:"heading-hold-on-condition"},"Heading Hold on Condition"),(0,r.kt)("p",null,"Tracking the desired flight path until UAV starts flaring, hence the bearing is not held until ",(0,r.kt)("strong",{parentName:"p"},"4")," conditions are stisfied according to PX4"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_param_fw_lnd_hhdist.get() > 0.0f")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"!_land_noreturn_horizontal")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"((wp_distance < _param_fw_lnd_hhdist.get()) ||_land_noreturn_vertical))"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"The Heading Hold is activated after Flare")),(0,r.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("ul",{parentName:"div"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_param_fw_lnd_hhdist.get()")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"FW_LND_HHDIST")," = ",(0,r.kt)("strong",{parentName:"li"},"15m")," (default value)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"FW_LND_FLALT")," or flare altitude = ",(0,r.kt)("strong",{parentName:"li"},"3m")," (default value)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_land_noreturn_vertical")," is activate when flaring phase just starts")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// we want the plane to keep tracking the desired flight path until we start flaring\n// if we go into heading hold mode earlier then we risk to be pushed away from the runway by cross winds\nif ((_param_fw_lnd_hhdist.get() > 0.0f) &&\n!_land_noreturn_horizontal &&\n((wp_distance < _param_fw_lnd_hhdist.get()) ||\n_land_noreturn_vertical)) {\n\n    if (pos_sp_prev.valid) {\n        /* heading hold, along the line connecting this and the last waypoint */\n        _target_bearing = bearing_lastwp_currwp;\n\n    } else {\n        _target_bearing = _yaw;\n    }\n\n    _land_noreturn_horizontal = true;\n    mavlink_log_info(&_mavlink_log_pub, "Landing, heading hold");\n}\n\nif (_land_noreturn_horizontal) {\n    // heading hold\n    _l1_control.navigate_heading(_target_bearing, _yaw, ground_speed);\n\n} else {\n    // normal navigation\n    _l1_control.navigate_waypoints(prev_wp, curr_wp, curr_pos, ground_speed);\n}\n\n_att_sp.roll_body = _l1_control.get_roll_setpoint();\n_att_sp.yaw_body = _l1_control.nav_bearing();\n\nif (_land_noreturn_horizontal) {\n    /* limit roll motion to prevent wings from touching the ground first */\n    /* Limit to 10 degs */\n    _att_sp.roll_body = constrain(_att_sp.roll_body, radians(-10.0f), radians(10.0f));\n}\n')),(0,r.kt)("h3",{id:"set-terrain-altitude"},"Set Terrain Altitude"),(0,r.kt)("p",null,"The terrain is initialised to help tell TECS and the controller what is the height difference, the logical sequence here is valid for ",(0,r.kt)("strong",{parentName:"p"},"terrain sensor (range sensors)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// default to no terrain estimation, just use landing waypoint altitude\nfloat terrain_alt = pos_sp_curr.alt;\n\nif (_param_fw_lnd_useter.get() == 1) {\n    if (_local_pos.dist_bottom_valid) {\n        // all good, have valid terrain altitude\n        float terrain_vpos = _local_pos.dist_bottom + _local_pos.z;\n        terrain_alt = (_local_pos.ref_alt - terrain_vpos);\n        _t_alt_prev_valid = terrain_alt;\n        _time_last_t_alt = now;\n\n    } else if (_time_last_t_alt == 0) {\n        // we have started landing phase but don't have valid terrain\n        // wait for some time, maybe we will soon get a valid estimate\n        // until then just use the altitude of the landing waypoint\n        if ((now - _time_started_landing) < 10_s) {\n            terrain_alt = pos_sp_curr.alt;\n\n        } else {\n            // still no valid terrain, abort landing\n            terrain_alt = pos_sp_curr.alt;\n            abort_landing(true);\n        }\n\n    } else if ((!_local_pos.dist_bottom_valid && (now - _time_last_t_alt) < T_ALT_TIMEOUT)\n            || _land_noreturn_vertical) {\n        // use previous terrain estimate for some time and hope to recover\n        // if we are already flaring (land_noreturn_vertical) then just\n        //  go with the old estimate\n        terrain_alt = _t_alt_prev_valid;\n\n    } else {\n        // terrain alt was not valid for long time, abort landing\n        terrain_alt = _t_alt_prev_valid;\n        abort_landing(true);\n    }\n}\n")),(0,r.kt)("h2",{id:"controls"},"Controls"),(0,r.kt)("h3",{id:"fw-descend"},"FW Descend"),(0,r.kt)("p",null,"We will evaluate the ",(0,r.kt)("inlineCode",{parentName:"p"},"else")," portion which is the descending of the UAV, following what PX4 has mentioned about unwanted climbout (",(0,r.kt)("inlineCode",{parentName:"p"},"checking for land_noreturn to avoid unwanted climb out"),")."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"altitude_desired = terrain_alt + landing_slope_alt_rel_desired;")," ensures the UAV stays on the slope.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"After which ",(0,r.kt)("inlineCode",{parentName:"p"},"_land_onslope = true")," and the UAV will follow the altitude desired for the next timestep and this will be passed to the ",(0,r.kt)("strong",{parentName:"p"},"TECS controller"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"tecs_update_pitch_throttle()")," will publish ",(0,r.kt)("inlineCode",{parentName:"p"},"_tecs_status_pub.publish(t)")," so tecs will control ",(0,r.kt)("strong",{parentName:"p"},"pitch")," and ",(0,r.kt)("strong",{parentName:"p"},"throttle"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"wp_distance")," distance from current to final waypoint."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'if ((_current_altitude < terrain_alt + _landingslope.flare_relative_alt()) ||\n    _land_noreturn_vertical) {  //checking for land_noreturn to avoid unwanted climb out\n    } else {\n\n    /* intersect glide slope:\n        * minimize speed to approach speed\n        * if current position is higher than the slope follow the glide slope (sink to the\n        * glide slope)\n        * also if the system captures the slope it should stay\n        * on the slope (bool land_onslope)\n        * if current position is below the slope continue at previous wp altitude\n        * until the intersection with slope\n        * */\n\n    float altitude_desired = terrain_alt;\n\n    const float landing_slope_alt_rel_desired = _landingslope.getLandingSlopeRelativeAltitudeSave(\n        wp_distance,\n        bearing_lastwp_currwp, \n        bearing_airplane_currwp);\n\n    if (_current_altitude > terrain_alt + landing_slope_alt_rel_desired || _land_onslope) {\n        /* stay on slope */\n        altitude_desired = terrain_alt + landing_slope_alt_rel_desired;\n\n        if (!_land_onslope) {\n            mavlink_log_info(&_mavlink_log_pub, "Landing, on slope");\n            _land_onslope = true;\n        }\n\n    } else {\n        /* continue horizontally */\n        if (pos_sp_prev.valid) {\n            altitude_desired = pos_sp_prev.alt;\n\n        } else {\n            altitude_desired = _current_altitude;\n        }\n    }\n\n    const float airspeed_approach = _param_fw_lnd_airspd_sc.get() * _param_fw_airspd_min.get();\n\n    tecs_update_pitch_throttle(\n        now,\n        altitude_desired,\n        calculate_target_airspeed(airspeed_approach, ground_speed),\n        radians(_param_fw_p_lim_min.get()),\n        radians(_param_fw_p_lim_max.get()),\n        _param_fw_thr_min.get(),\n        _param_fw_thr_max.get(),\n        _param_fw_thr_cruise.get(),\n        false,\n        radians(_param_fw_p_lim_min.get()));\n    }\n')),(0,r.kt)("h3",{id:"fw-flare"},"FW Flare"),(0,r.kt)("p",null,"Condition to activate flare is ",(0,r.kt)("inlineCode",{parentName:"p"},"(_current_altitude < terrain_alt + _landingslope.flare_relative_alt())")," this is when the current altitude low enough to activate the flare which is around ",(0,r.kt)("inlineCode",{parentName:"p"},"FW_LND_FLALT")," height."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'    if ((_current_altitude < terrain_alt + _landingslope.flare_relative_alt()) ||\n    _land_noreturn_vertical) {\n    /* land with minimal speed */\n\n    /* force TECS to only control speed with pitch, altitude is only implicitly controlled now */\n    // _tecs.set_speed_weight(2.0f);\n\n    /* kill the throttle if param requests it */\n    float throttle_max = _param_fw_thr_max.get();\n\n    /* enable direct yaw control using rudder/wheel */\n    if (_land_noreturn_horizontal) {\n        _att_sp.yaw_body = _target_bearing;\n        _att_sp.fw_control_yaw = true;\n    }\n\n    if (((_current_altitude < terrain_alt + _landingslope.motor_lim_relative_alt()) &&\n            (wp_distance_save < _landingslope.flare_length() + 5.0f)) || // Only kill throttle when close to WP\n        _land_motor_lim) {\n        throttle_max = min(throttle_max, _param_fw_thr_lnd_max.get());\n\n        if (!_land_motor_lim) {\n            _land_motor_lim  = true;\n            mavlink_log_info(&_mavlink_log_pub, "Landing, limiting throttle");\n        }\n    }\n\n    float flare_curve_alt_rel = _landingslope.getFlareCurveRelativeAltitudeSave(wp_distance, bearing_lastwp_currwp,\n                    bearing_airplane_currwp);\n\n    /* avoid climbout */\n    if ((_flare_curve_alt_rel_last < flare_curve_alt_rel && _land_noreturn_vertical) || _land_stayonground) {\n        flare_curve_alt_rel = 0.0f; // stay on ground\n        _land_stayonground = true;\n    }\n\n    const float airspeed_land = _param_fw_lnd_airspd_sc.get() * _param_fw_airspd_min.get();\n    const float throttle_land = _param_fw_thr_min.get() + (_param_fw_thr_max.get() - _param_fw_thr_min.get()) * 0.1f;\n\n    tecs_update_pitch_throttle(\n        now,\n        terrain_alt + flare_curve_alt_rel,\n        calculate_target_airspeed(airspeed_land, ground_speed),\n        radians(_param_fw_lnd_fl_pmin.get()),\n        radians(_param_fw_lnd_fl_pmax.get()),\n        0.0f,\n        throttle_max,\n        throttle_land,\n        false,\n        _land_motor_lim ? radians(_param_fw_lnd_fl_pmin.get()) : radians(_param_fw_p_lim_min.get()),\n        _land_motor_lim ? tecs_status_s::TECS_MODE_LAND_THROTTLELIM : tecs_status_s::TECS_MODE_LAND);\n\n    if (!_land_noreturn_vertical) {\n        // just started with the flaring phase\n        _flare_pitch_sp = radians(_param_fw_psp_off.get());\n        _flare_height = _current_altitude - terrain_alt;\n        mavlink_log_info(&_mavlink_log_pub, "Landing, flaring");\n        _land_noreturn_vertical = true;\n\n    } else {\n        if (_local_pos.vz > 0.1f) {\n            _flare_pitch_sp = radians(_param_fw_lnd_fl_pmin.get()) *\n            constrain((_flare_height - (_current_altitude - terrain_alt)) / _flare_height, 0.0f, 1.0f);\n        }\n\n        // otherwise continue using previous _flare_pitch_sp\n    }\n\n    _att_sp.pitch_body = _flare_pitch_sp;\n    _flare_curve_alt_rel_last = flare_curve_alt_rel;\n    }\n')),(0,r.kt)("h2",{id:"helper-functions"},"Helper Functions"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"get_bearing_to_next_waypoint")," can be found in the ",(0,r.kt)("inlineCode",{parentName:"p"},"geo.cpp")," under ",(0,r.kt)("inlineCode",{parentName:"p"},"ecl/geo.cpp")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"float get_bearing_to_next_waypoint(double lat_now, double lon_now, double lat_next, double lon_next)\n{\n    const double lat_now_rad = math::radians(lat_now);\n    const double lat_next_rad = math::radians(lat_next);\n\n    const double cos_lat_next = cos(lat_next_rad);\n    const double d_lon = math::radians(lon_next - lon_now);\n\n    /* conscious mix of double and float trig function to maximize speed and efficiency */\n\n    const float y = static_cast<float>(sin(d_lon) * cos_lat_next);\n    const float x = static_cast<float>(cos(lat_now_rad) * sin(lat_next_rad) - sin(lat_now_rad) * cos_lat_next * cos(d_lon));\n\n    return wrap_pi(atan2f(y, x));\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"wrap_pi")," can be found in the ",(0,r.kt)("inlineCode",{parentName:"p"},"matrix/matrix/helper_functions.hpp")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#define M_PI 3.14159265358979323846\n/**\n * Wrap value in range [-\u03c0, \u03c0)\n */\ntemplate<typename Type>\nType wrap_pi(Type x)\n{\n    return wrap(x, Type(-M_PI), Type(M_PI));\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"getLandingSlopeRelativeAltitudeSave")," can be found in the directory ",(0,r.kt)("inlineCode",{parentName:"p"},"landing_slope/Landingslope.cpp")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"float\nLandingslope::getLandingSlopeRelativeAltitudeSave(\n    float wp_landing_distance, \n    float bearing_lastwp_currwp,\n    float bearing_airplane_currwp)\n{\n    /* If airplane is in front of waypoint return slope altitude, else return waypoint altitude */\n    if (fabsf(matrix::wrap_pi(bearing_airplane_currwp - bearing_lastwp_currwp)) < math::radians(90.0f)) {\n        return getLandingSlopeRelativeAltitude(wp_landing_distance);\n\n    }\n\n    return 0.0f;\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"getLandingSlopeRelativeAltitude")," can be found in the directory ",(0,r.kt)("inlineCode",{parentName:"p"},"landing_slope/Landingslope.cpp")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"/**\n *\n * @return Relative altitude of point on landing slope at distance to landing waypoint=wp_landing_distance\n */\nfloat Landingslope::getLandingSlopeRelativeAltitude(float wp_landing_distance, float horizontal_slope_displacement,\n        float landing_slope_angle_rad)\n{\n    // flare_relative_alt is negative\n    return (wp_landing_distance - horizontal_slope_displacement) * tanf(landing_slope_angle_rad);\n}\n")))}c.isMDXComponent=!0},5156:function(e,t,n){"use strict";t.Z=n.p+"assets/images/fw_landing_path-a1df1b58a0d422ee30986d1424aa157d.png"},3327:function(e,t,n){"use strict";t.Z=n.p+"assets/images/landing_params-f2d6008c2636b6391865896839cd916e.png"},936:function(e,t,n){"use strict";t.Z=n.p+"assets/images/landing_qgc-4bb497b421098d0041d86d6ef534eb06.png"},552:function(e,t,n){"use strict";t.Z=n.p+"assets/images/landing_terminal-2700f82727efa381c7889446a58a9d64.png"},1755:function(e,t,n){"use strict";t.Z=n.p+"assets/images/mav_setpoints-033d7e10613228e0d697020dc05c26bb.png"}}]);